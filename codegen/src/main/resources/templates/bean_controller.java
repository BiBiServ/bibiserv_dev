/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * Copyright 2010-2013 BiBiServ Curator Team, http://bibiserv.cebitec.uni-bielefeld.de,
 * All rights reserved.
 *
 * The contents of this file are subject to the terms of the Common
 * Development and Distribution License("CDDL") (the "License"). You
 * may not use this file except in compliance with the License. You can
 * obtain a copy of the License at http://www.sun.com/cddl/cddl.html
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.  When distributing the software, include
 * this License Header Notice in each file.  If applicable, add the following
 * below the License Header, with the fields enclosed by brackets [] replaced
 *  by your own identifying information:
 *
 * "Portions Copyrighted 2010-2013 BiBiServ Curator Team, http://bibiserv.cebitec.uni-bielefeld.de"
 *
 * Contributor(s):  Daniel Hagemeier - dhagemei[aet]cebitec.uni-bielefeld.de
 *                  Armin Toepfer - atoepfer[aet]cebitec.uni-bielefeld.de
 *                  Jan Krueger - jkrueger[aet]cebitec.uni-bielefeld.de
 *
 */
package <#getPackageName/#>;

import de.unibi.cebitec.bibiserv.util.convert.ConversionException;
import de.unibi.cebitec.bibiserv.util.validate.ValidationException;
import de.unibi.techfak.bibiserv.util.ontoaccess.bibiontotypes.OntoRepresentation;
import de.unibi.cebitec.bibiserv.utils.SiblingGetter;
import de.unibi.cebitec.bibiserv.statistics.logging.StatsLoggerI;
import de.unibi.cebitec.bibiserv.utils.Cookie;
import de.unibi.techfak.bibiserv.BiBiTools;
import de.unibi.techfak.bibiserv.cms.Texample;
import de.unibi.techfak.bibiserv.cms.Texample.Prop;

import de.unibi.techfak.bibiserv.web.beans.session.MessagesInterface;
import de.unibi.techfak.bibiserv.util.Pair;
import de.unibi.techfak.bibiserv.exception.BiBiToolsException;
import de.unibi.techfak.bibiserv.tools.<#getToolId/#>.ParameterDependencies;
import de.unibi.techfak.bibiserv.tools.<#getToolId/#>.Tooldescription;
import de.unibi.techfak.bibiserv.tools.<#getToolId/#>.<#getFunctionId/#>;
import de.unibi.techfak.bibiserv.util.dependencyparser.ConstraintHashMap;
import de.unibi.techfak.bibiserv.util.dependencyparser.Constraints;
import de.unibi.techfak.bibiserv.util.dependencyparser.DependencyException;
import de.unibi.techfak.bibiserv.util.dependencyparser.Id;
import de.unibi.techfak.bibiserv.util.dependencyparser.Node;
import de.unibi.techfak.bibiserv.util.dependencyparser.ParameterWrapper;
import de.unibi.techfak.bibiserv.web.beans.session.InputBeanInterface;
import java.io.IOException;
import java.util.ArrayList;

import java.util.List;
import org.primefaces.context.RequestContext;
import javax.faces.context.FacesContext;
import javax.faces.event.ActionEvent;
import javax.faces.event.ValueChangeEvent;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

import de.unibi.techfak.bibiserv.web.beans.session.RequestOpenUrlQueueBeanInterface;
import de.unibi.techfak.bibiserv.web.beans.session.ToolChainItem;
import de.unibi.techfak.bibiserv.web.beans.session.ToolChainingBeanInterface;
import de.unibi.techfak.bibiserv.web.beans.session.ToolFunctionController;
import javax.annotation.PreDestroy;

/**
 * This is a autogenerated bean controller template class for function <i><#getClassName/#></i>
 *
 * @author Daniel Hagemeier - dhagemei[aet]cebitec.uni-bielefeld.de
 *         Armin Toepfer - atoepfer[aet]cebitec.uni-bielefeld.de
 *         Jan Krueger - jkrueger[aet]cebitec.uni-bielefeld.de
 */
public class <#getClassName/#> implements InitializingBean, DisposableBean, ToolFunctionController {

    private final static Logger log = Logger.getLogger(de.unibi.techfak.bibiserv.tools.<#getToolId/#>.web.<#getFunctionId/#>_controller.class);
    private final String br = System.getProperty("line.separator");



        /* #########################################
     * #   DI method setguugle and field   #
     * ######################################### */
    public <#getToolId/#>_function function;

    public void setFunction(<#getToolId/#>_function function) {
        this.function = function;
    }

    /* #########################################
     * #     DI method setMessages             #
     * ######################################### */
    private MessagesInterface messages;

    public void setMessages(MessagesInterface messages) {
        this.messages = messages;
    }
    
    /* #########################################
     * #     DI method setUrlQueueBean             #
     * ######################################### */
    private RequestOpenUrlQueueBeanInterface urlQueueBean;

    public void setUrlQueueBean(RequestOpenUrlQueueBeanInterface urlQueueBean) {
        this.urlQueueBean = urlQueueBean;
    }

    /* #########################################
     * # DI method setParameterDependencies    #
     * ######################################### */
    private ParameterDependencies pdp;

    public void setParameterDependencies(ParameterDependencies pdp) {
        this.pdp = pdp;
    }

    /* #########################################
     * #     DI method setStatsLogger          #
     * ######################################### */
    private StatsLoggerI statsLogger;

    public void setStatsLogger(StatsLoggerI statsLogger) {
        this.statsLogger = statsLogger;
    }

    
    
    /* #########################################
     * #     DI method setInput(s)             #
     * ######################################### */
    <#for_each_input#>
    public InputBeanInterface ___INPUT_ID___;

    public void setInput___NUMBER___(InputBeanInterface ___INPUT_ID___) {
        this.___INPUT_ID___ = ___INPUT_ID___;
        // tell input to register if it needs to register itself somewhere
        this.___INPUT_ID___.register(this.execfunction.getFunctionId());
    }
    <#/for_each_input#>
    
    /**
     * This is called when the bean is destroyed. All inputs are told to unregister. 
     */
    @PreDestroy
    public void onDestroy(){
         <#for_each_input#>
          this.___INPUT_ID___.unregister(this.execfunction.getFunctionId());
         <#/for_each_input#>
    }
    
    @Override
    public List<InputBeanInterface> getInputs() {
        List<InputBeanInterface> input = new ArrayList<InputBeanInterface>();
        
         <#for_each_input#>
          input.add(___INPUT_ID___);
         <#/for_each_input#>
        return input;
    }

    /* #########################################
     * #     DI method setParam                 #
     * ######################################### */
    public <#getFunctionId/#>_param param;

    public void setParam(<#getFunctionId/#>_param param) {
        this.param = param;
    }

    /* #########################################
     * #     DI method setResult               #
     * ######################################### */
    public <#getFunctionId/#>_result result;

    public void setResult(<#getFunctionId/#>_result result) {
        this.result = result;
    }
    
    /* #########################################
     * #     DI method setResultHandler        #
     * ######################################### */
    public <#getFunctionId/#>_resulthandler resulthandler;

    public void setResulthandler(<#getFunctionId/#>_resulthandler resulthandler) {
        this.resulthandler = resulthandler;
    }

    /* #########################################
     * #     DI method setExecfunction          #
     * ######################################### */
    public <#getFunctionId/#> execfunction;

    public void setExecfunction(<#getFunctionId/#> execfunction) {
        this.execfunction = execfunction;
    }
    
      /* #########################################
     * #     DI method setTooldescription       #
     * ######################################### */
    public Tooldescription tooldescription;

    public void setTooldescription(Tooldescription tooldescription) {
        this.tooldescription = tooldescription;
    }
    
    /* #########################################
     * # Returns all Representations as String #
     * ######################################### */
    <#for_each_input#>
    public String getSupportedFormats___NUMBER___() {
        OntoRepresentation base = execfunction.getRepresentationInput___NUMBER___();
        
        List<OntoRepresentation> possibleRepresentations = new ArrayList<OntoRepresentation>();
        possibleRepresentations.add(base);
        possibleRepresentations.addAll(SiblingGetter.getSiblingsConvertableTo(base));

        StringBuilder sup = new StringBuilder();
        
        sup.append(base.getContentDescription()).append(": ");
        
        boolean first = true;
        for (OntoRepresentation representation : possibleRepresentations) {
            if(first){
                 sup.append(representation.getFormatLabel());
                 first = false;
             } else {
                 sup.append(", ").append(representation.getFormatLabel());
             }
        }
        return sup.toString();
    }
    
    public String getSupportedFormatsStream___NUMBER___() {
        OntoRepresentation base = execfunction.getRepresentationInput___NUMBER___();
        
        List<OntoRepresentation> possibleRepresentations = new ArrayList<OntoRepresentation>();
        possibleRepresentations.add(base);
        possibleRepresentations.addAll(SiblingGetter.getSiblingsStreamConvertableTo(base));

        StringBuilder sup = new StringBuilder();
        
        sup.append(base.getContentDescription()).append(": ");
         
        boolean first = true;
        for (OntoRepresentation representation : possibleRepresentations) {
            if(first){
                 sup.append(representation.getFormatLabel());
                 first = false;
             } else {
                 sup.append(", ").append(representation.getFormatLabel());
             }
        }
        return sup.toString();
    }
    
    
    public String getToolMainFormat___NUMBER___() {
        OntoRepresentation base = execfunction.getRepresentationInput___NUMBER___();
        return base.getFormatLabel();
    }
    
    
     public String getToolMainFormatFull___NUMBER___() {
        OntoRepresentation base = execfunction.getRepresentationInput___NUMBER___();
        return base.getContentDescription()+": "+base.getFormatLabel();
    }
    
    <#/for_each_input#>
    
    /* ################################################
     * # Implementation of Interface InitializingBean #
     * ################################################ */
   
    private Node dptree;
    private ParameterWrapper parameterwrapper;

    public void afterPropertiesSet() throws Exception {
        // create new parameterwrapper
        parameterwrapper = new ParameterWrapper();
        // get DependencyTree
        dptree = pdp.getDependencyTree("<#getFunctionId/#>", parameterwrapper);
    }

    /* ###############################################
     * # Implementation of Interface Disposable Bean #
     * ############################################### */
    public void destroy() throws Exception {       
    }

    /* #########################################
     * #     waiting dialig showing beans      #
     * ######################################### */
    

    public boolean isInputValidated() {
        return true 
                <#for_each_input#>
                && ___INPUT_ID___.isValid()
                <#/for_each_input#>;
                
    }
    
   
    
    
   /* ###############################################################################
     * # Callbackfunction sending success of validation to client with RequestContext#
     * ############################################################################## */
     public void callback() {
      
        RequestContext context = RequestContext.getCurrentInstance();
        context.addCallbackParam("validated",true<#for_each_input#>&&___INPUT_ID___.isValidated()<#/for_each_input#>);
        
        urlQueueBean.requestNextLaunch(); // look if any request windows have to be opened for Illumina BaseSpace
        
         if (true<#for_each_input#>&&___INPUT_ID___.isValid()<#/for_each_input#>) {     
             log.debug("Request to callback validation....");
             context.addCallbackParam("redirection",true ); 
             context.addCallbackParam("location", "2"); 
             // resetting values for the user returning to input page...
             
             <#for_each_input#>
             ___INPUT_ID___.setValidated(false);
             if(___INPUT_ID___.getInput().getRepresentations().size()>1) {
                 context.addCallbackParam("location", "1b"); 
             }
             <#/for_each_input#>
            }

    }
    
   
    /* #########################################
     * # Validation method for this function   #
     * # initialised by Calculate-Button       #
     * ######################################### */
    public void validate(ActionEvent e) {
        log.info("call validate ...");
        <#ifInput#>

        // set needed i18n properties in string array, facescontext.currentInstance return
        // null value, when called from new internal thread
        final String[] args = new String[]{
            messages.property("de.unibi.techfak.bibiserv.bibimainapp.input.UPLOAD"),
            messages.property("de.unibi.techfak.bibiserv.bibimainapp.input.NOFILE"),
            messages.property("de.unibi.techfak.bibiserv.bibimainapp.input.COPYPASTE"),
            messages.property("de.unibi.techfak.bibiserv.bibimainapp.input.NODATA"),
            messages.property("de.unibi.techfak.bibiserv.bibimainapp.input.NOXML"),
            messages.property("de.unibi.techfak.bibiserv.bibimainapp.input.CHECK"),
            messages.property("de.unibi.techfak.bibiserv.bibimainapp.input.MESSAGE")
        };

        // validation can be time consuming, so start validation in an extra thread
        Thread validation = new Thread(new Runnable() {

            public void run() {
                OntoRepresentation target = null;
                <#for_each_input#>
                target = execfunction.getRepresentationInput___NUMBER___();
                ___INPUT_ID___.determineSourceAndValidate(args,target, execfunction.getFunctionId());
                <#/for_each_input#>
                log.info("Validation finished ...");
               
                    //disable error field(s)
                    <#for_each_input#>
                    if (___INPUT_ID___.isValid()){
                        ___INPUT_ID___.setShowInfo(false);
                    }
                    
                    <#/for_each_input#>
                    
                } 
               
            
        });
        
        validation.start();
        <#/ifInput#>
    }


    /* #########################################
     * # Calculation method for this function  #
     * # initialised by Calculate-Button       #
     * ######################################### */
    public void calculate(ActionEvent e) {
        
        // only resume if the resulthandler is valid
        if(!resulthandler.validate()){
            return;
        }
        
        try {
            log.info("Called calculate");

            final List<Pair<String, String>> pairlist = param.getParameterList();
            
            /* ---------------------- Stats ---------------------- */
            statsLogger.logSubmit("<#getToolId/#>_submission", function.getSessionId(), defaultParams(), defaultInputs());
            long startTime = System.currentTimeMillis();

            try {
                /* check each combination of inputs and call appropriate function */
                String requestid;
                String secretkey = resulthandler.getSecretKey();
                String accesskey = resulthandler.getAccessKey();
                String sessiontoken = resulthandler.getSessionToken();
                if(resulthandler.getResultHandling()==resulthandler.getResultHandling().s3upload) {
                    String uploadbucket = resulthandler.getSelected_item_bucket();
                    String uploadfolder = resulthandler.getSubfolder();
                    result.setShowMessage(true);
                    result.setCalculateMessage(messages.property("de.unibi.techfak.bibiserv.bibimainapp.result.UPLOAD_COMPLETED"));
                    
                    <#generate_exec_request#>, uploadbucket, uploadfolder<#/generate_exec_request#>
                } else {
                    result.setShowMessage(false);
                    <#generate_exec_request#> <#/generate_exec_request#>
                }
                result.setBibiservid(requestid);
                
                // save bibiservid in Cookie      
                Cookie.addBiBiServId(FacesContext.getCurrentInstance().getExternalContext(), requestid, Integer.parseInt(BiBiTools.getProperties().getProperty("result.storage.time", Integer.toString(60*60*24*3)))); 


            } catch (BiBiToolsException ex) {
                log.fatal("BiBiToolException occurred! ", ex);
            } catch (ConversionException ex) {
                log.fatal("ConversionException occurred (should never happend at this point)! ", ex);
            } catch (ValidationException ex) {
                log.fatal("ValidateException occurred (should never happend at this point)! ", ex);
            }
            statsLogger.logRuntime("<#getToolId/#>_submission", function.getSessionId(), result.getBibiservid(), (System.currentTimeMillis() - startTime) / 1000, result.getStatuscode(), result.getStatusdescription());

            FacesContext.getCurrentInstance().getExternalContext().redirect("/<#getToolId/#>?viewType=submission&subType=<#getFunctionId/#>_result");

        } catch (IOException ex){
            log.fatal(ex.getMessage());
        } 
        
    }
    
    
    /* #########################################
     * # Calculation method for this function  #
     * # initialised by Calculate-Button       #
     * ######################################### */
    public void paramSet(ActionEvent e) {
        log.info("Called Paramset");

        // if parameters aren't valid ,return without calculation
        if (!param.isValid()) {
            log.debug("Parameters aren't valid, abbort further calculation ...");
            return;
        }

        /* -------------------- Parameter -------------------- */
        final List<Pair<String, String>> pairlist = param.getParameterList();

        parameterwrapper.setParameter(pairlist);


        // if tree evaluates to true we can start the calculation
        try {
            if (dptree.evaluate()) {

                FacesContext.getCurrentInstance().getExternalContext().redirect("/<#getToolId/#>?viewType=submission&subType=<#getFunctionId/#>_p_3");

            } else {
                ConstraintHashMap chm = dptree.getMissingConstraints();
                FacesContext fc = FacesContext.getCurrentInstance();
                for (Id id : chm.keySet()) {
                    List<Constraints> constraints = chm.get(id);
                    // Constraints list is null  or is empty parameter 'id' is missing without further constraints.
                    if (constraints == null || constraints.isEmpty()) {
                        param.addFaultmsg(id.getId()+"_<#getFunctionId/#>","Parameter '"+id.getId()+"' is mandantory !");
                    } else {
                        StringBuilder sb = new StringBuilder("Parameter  '"+id.getId()+" is mandantory and must fullfill the constraints : ");
                        for (Constraints constraint : constraints) {
                            sb.append("'");
                            sb.append(constraint.toString());
                            sb.append("' ");
                        }
                        param.addFaultmsg(id.getId()+"_<#getFunctionId/#>",sb.toString());
                    }
                }
            }
        } catch (DependencyException ex) {
            log.fatal(ex.getMessage(), ex);
        } catch (IOException ex){
            log.fatal(ex.getMessage());
        } 
    }

    /* ##################
     * # reset function #
     * ################## */
    public void reset() {
        resetParam(null);
        resetInput(null);
    }

    public void resetParam(ActionEvent e) {
        param.reset();
    }

    public void resetInput(ActionEvent e) {
        <#for_each_input#>
        ___INPUT_ID___.reset();
        <#/for_each_input#>
        
    }
    
      /* ######################
     * # example function(s) #
     * ####################### */
    
    

    /**  
     * Return the count of examples for this function 
     * 
     * @return number of examples for current function
     */
    public int getExampleCount(){             
        return tooldescription.getFunction("<#getFunctionId/#>").getExample().size();
    }
       
    /**
     * ExampleActionListener, used by example button and example som chooser.
     * 
     * Replace values with the given example values.
     */
    public void example(int i) {
       Texample te = tooldescription.getFunction("<#getFunctionId/#>").getExample().get(i);
       // iterate over all properties
       for (Prop p : te.getProp()) {
           <#for_each_input#>___INPUT_ID___.checkAndSet(p);
           <#/for_each_input#>
           
           param.checkAndSet(p);
       }
    }
    
     public String exampleName(int i) {
        return tooldescription.getFunction("<#getFunctionId/#>").getExample().get(i).getName().get(0).getValue();
    }
     
     /**
     * Return true in the case that input(s) follows (one of) the input example
     * 
     * @return 
     */
    
     public boolean defaultInputs(){
         return false;
     }
     
     /**
      * 
      * @return  Return true in the case the param(s) follows the example
      */
     public boolean defaultParams(){
         return false;
     }
     
     
     ////////////////////////////////////////////////////////
     //             Toolchaining Extension                 //
     ////////////////////////////////////////////////////////
     
    private ToolChainingBeanInterface toolChainBean;

    public void setToolChainBean(ToolChainingBeanInterface chainingBean) {
        this.toolChainBean = chainingBean;
    }


    @Override
    public List<Pair<String, Pair<String, List<ToolChainItem>>>> getToolchainStarts(String input) {
        List<Pair<String, Pair<String, List<ToolChainItem>>>> items = new ArrayList<>();
        
        // TODO TG: Add the start items you want to have for each input 
        // and uncomment the corresponding b:toolchainstart tag in _p_1
        
        // exmaple start item for dialign
//        ToolChainItem dialign = new ToolChainItem("dialign_function_dna", 0, "/genefisher2?viewType=submission&subType=batcons2_function_dna_p_1", batcons2_function_dna_controller.class, "batcons2_function_dna_controller", "Genefisher Consensus Caculation", "Genefisher Toolchain");
//        List<ToolChainItem> dialign_chain = new ArrayList<>();
//        dialign_chain.add(dialign);
//        
//        Pair<String, List<ToolChainItem>> dialign_chain_pair = new Pair<>("/dialign?viewType=submission&subType=dialign_function_dna_p_1", dialign_chain);
//        items.add(new Pair<>("Dialign", dialign_chain_pair));
        
        <#for_each_input#>if("___INPUT_ID___".equals(input)) {
            
        }
        <#/for_each_input#>
        
        return items;
    }

    @Override
    public void startToolChain(String startUrl, List<ToolChainItem> list) {
        toolChainBean.resetChain();
        try {
            
            // set full chain
            for(ToolChainItem item:list) {
                toolChainBean.addChainItem(item);
            }
            
            FacesContext.getCurrentInstance().getExternalContext().redirect(startUrl);
        } catch ( IOException ex) {
        }
    }
     
     
}
